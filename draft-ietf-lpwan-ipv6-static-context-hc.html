<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>LPWAN Static Context Header Compression (SCHC) and fragmentation for IPv6 and UDP</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 LPWAN Architecture">
<link href="#rfc.section.3" rel="Chapter" title="3 Terminology">
<link href="#rfc.section.4" rel="Chapter" title="4 Static Context Header Compression">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 SCHC Rules">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Rule ID">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Packet processing">
<link href="#rfc.section.5" rel="Chapter" title="5 Matching operators">
<link href="#rfc.section.6" rel="Chapter" title="6 Compression Decompression Actions (CDA)">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 not-sent CDA">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 value-sent CDA">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 mapping-sent">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 LSB CDA">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 DEViid, APPiid CDA">
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Compute-*">
<link href="#rfc.section.7" rel="Chapter" title="7 Application to IPv6 and UDP headers">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 IPv6 version field">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 IPv6 Traffic class field">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Flow label field">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Payload Length field">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Next Header field">
<link href="#rfc.section.7.6" rel="Chapter" title="7.6 Hop Limit field">
<link href="#rfc.section.7.7" rel="Chapter" title="7.7 IPv6 addresses fields">
<link href="#rfc.section.7.7.1" rel="Chapter" title="7.7.1 IPv6 source and destination prefixes">
<link href="#rfc.section.7.7.2" rel="Chapter" title="7.7.2 IPv6 source and destination IID">
<link href="#rfc.section.7.8" rel="Chapter" title="7.8 IPv6 extensions">
<link href="#rfc.section.7.9" rel="Chapter" title="7.9 UDP source and destination port">
<link href="#rfc.section.7.10" rel="Chapter" title="7.10 UDP length field">
<link href="#rfc.section.7.11" rel="Chapter" title="7.11 UDP Checksum field">
<link href="#rfc.section.8" rel="Chapter" title="8 Examples">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 IPv6/UDP compression">
<link href="#rfc.section.9" rel="Chapter" title="9 Fragmentation">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Overview">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Reliability options: definition">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Reliability options: discussion">
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Tools">
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 Formats">
<link href="#rfc.section.9.5.1" rel="Chapter" title="9.5.1 Fragment format">
<link href="#rfc.section.9.5.2" rel="Chapter" title="9.5.2 Fragmentation header formats">
<link href="#rfc.section.9.5.3" rel="Chapter" title="9.5.3 ACK format">
<link href="#rfc.section.9.6" rel="Chapter" title="9.6 Baseline mechanism">
<link href="#rfc.section.9.7" rel="Chapter" title="9.7 Supporting multiple window sizes">
<link href="#rfc.section.9.8" rel="Chapter" title="9.8 Aborting fragmented IPv6 datagram transmissions">
<link href="#rfc.section.9.9" rel="Chapter" title="9.9 Downlink fragment transmission">
<link href="#rfc.section.10" rel="Chapter" title="10 Security considerations">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Security considerations for header compression">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Security considerations for fragmentation">
<link href="#rfc.section.11" rel="Chapter" title="11 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="12 References">
<link href="#rfc.references.1" rel="Chapter" title="12.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="12.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Fragmentation examples">
<link href="#rfc.appendix.B" rel="Chapter" title="B Rule IDs for fragmentation">
<link href="#rfc.appendix.C" rel="Chapter" title="C Note">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.6.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Minaburo, A., Toutain, L., and C. Gomez" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-lpwan-ipv6-static-context-hc-04" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-6-28" />
  <meta name="dct.abstract" content="This document describes a header compression scheme and fragmentation functionality for very low bandwidth networks. These techniques are especially tailored for LPWAN (Low Power Wide Area Network) networks." />
  <meta name="description" content="This document describes a header compression scheme and fragmentation functionality for very low bandwidth networks. These techniques are especially tailored for LPWAN (Low Power Wide Area Network) networks." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">lpwan Working Group</td>
<td class="right">A. Minaburo</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Acklio</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">L. Toutain</td>
</tr>
<tr>
<td class="left">Expires: December 30, 2017</td>
<td class="right">IMT-Atlantique</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Gomez</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Universitat Polit&#232;cnica de Catalunya</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">June 28, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">LPWAN Static Context Header Compression (SCHC) and fragmentation for IPv6 and UDP<br />
  <span class="filename">draft-ietf-lpwan-ipv6-static-context-hc-04</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes a header compression scheme and fragmentation functionality for very low bandwidth networks. These techniques are especially tailored for LPWAN (Low Power Wide Area Network) networks.</p>
<p>The Static Context Header Compression (SCHC) offers a great level of flexibility when  processing the header fields and must be used for these kind of networks. A common context stored in a LPWAN device and in the  network is used. This context keeps information that will not be transmitted in the constrained network.  Static context means that information stored in the context which describes field values, does not change during packet transmission, avoiding complex resynchronization mechanisms, incompatible with LPWAN characteristics. In most of the cases, IPv6/UDP headers are reduced to a small identifier called Rule ID. But sometimes the SCHC header compression mechanisms will not be enough to send the compressed packet in one L2 PDU, so the SCHC Fragmentation protocol must be used when needed.</p>
<p>This document describes SCHC compression/decompression mechanism framework and applies it to IPv6/UDP headers. Similar solutions for other protocols such as CoAP will be described in separate documents. Moreover, this document specifies fragmentation and reassembly mechanim for SCHC compressed packets exceeding the L2 PDU size and for the case where the SCHC compression is not possible then the packet is sent using the fragmentation protocol.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 30, 2017.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">LPWAN Architecture</a>
</li>
<li>3.   <a href="#rfc.section.3">Terminology</a>
</li>
<li>4.   <a href="#rfc.section.4">Static Context Header Compression</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">SCHC Rules</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Rule ID</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Packet processing</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Matching operators</a>
</li>
<li>6.   <a href="#rfc.section.6">Compression Decompression Actions (CDA)</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">not-sent CDA</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">value-sent CDA</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">mapping-sent</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">LSB CDA</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">DEViid, APPiid CDA</a>
</li>
<li>6.6.   <a href="#rfc.section.6.6">Compute-*</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Application to IPv6 and UDP headers</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">IPv6 version field</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">IPv6 Traffic class field</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Flow label field</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Payload Length field</a>
</li>
<li>7.5.   <a href="#rfc.section.7.5">Next Header field</a>
</li>
<li>7.6.   <a href="#rfc.section.7.6">Hop Limit field</a>
</li>
<li>7.7.   <a href="#rfc.section.7.7">IPv6 addresses fields</a>
</li>
<ul><li>7.7.1.   <a href="#rfc.section.7.7.1">IPv6 source and destination prefixes</a>
</li>
<li>7.7.2.   <a href="#rfc.section.7.7.2">IPv6 source and destination IID</a>
</li>
</ul><li>7.8.   <a href="#rfc.section.7.8">IPv6 extensions</a>
</li>
<li>7.9.   <a href="#rfc.section.7.9">UDP source and destination port</a>
</li>
<li>7.10.   <a href="#rfc.section.7.10">UDP length field</a>
</li>
<li>7.11.   <a href="#rfc.section.7.11">UDP Checksum field</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Examples</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">IPv6/UDP compression</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Fragmentation</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Overview</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Reliability options: definition</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Reliability options: discussion</a>
</li>
<li>9.4.   <a href="#rfc.section.9.4">Tools</a>
</li>
<li>9.5.   <a href="#rfc.section.9.5">Formats</a>
</li>
<ul><li>9.5.1.   <a href="#rfc.section.9.5.1">Fragment format</a>
</li>
<li>9.5.2.   <a href="#rfc.section.9.5.2">Fragmentation header formats</a>
</li>
<li>9.5.3.   <a href="#rfc.section.9.5.3">ACK format</a>
</li>
</ul><li>9.6.   <a href="#rfc.section.9.6">Baseline mechanism</a>
</li>
<li>9.7.   <a href="#rfc.section.9.7">Supporting multiple window sizes</a>
</li>
<li>9.8.   <a href="#rfc.section.9.8">Aborting fragmented IPv6 datagram transmissions</a>
</li>
<li>9.9.   <a href="#rfc.section.9.9">Downlink fragment transmission</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">Security considerations</a>
</li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Security considerations for header compression</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">Security considerations for fragmentation</a>
</li>
</ul><li>11.   <a href="#rfc.section.11">Acknowledgements</a>
</li>
<li>12.   <a href="#rfc.references">References</a>
</li>
<ul><li>12.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>12.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Fragmentation examples</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Rule IDs for fragmentation</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Note</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#Introduction" id="Introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Header compression is mandatory to efficiently bring Internet connectivity to the node within a LPWAN network. Some LPWAN networks properties can be exploited to get an efficient header compression:</p>
<p></p>

<ul>
<li>Topology is star-oriented, therefore all the packets follow the same path.  For the needs of this draft, the architecture can be summarized to Devices (Dev) exchanging information with LPWAN Application Server (App) through a Network Gateway (NGW).</li>
<li>Traffic flows are mostly known in advance, since devices embed built-in applications. Contrary to computers or smartphones, new applications cannot be easily installed.</li>
</ul>
<p id="rfc.section.1.p.3">The Static Context Header Compression (SCHC) is defined for this environment.  SCHC uses a context where header information is kept in the header format order. This context is static (the values on the header fields do not change over time) avoiding complex resynchronization mechanisms, incompatible with LPWAN characteristics. In most of the cases, IPv6/UDP headers are reduced to a small context identifier.</p>
<p id="rfc.section.1.p.4">The SCHC header compression mechanism is independent from the specific LPWAN technology over which it will be used.</p>
<p id="rfc.section.1.p.5">LPWAN technologies are also characterized, among others, by a very reduced data unit and/or payload size <a href="#I-D.ietf-lpwan-overview" class="xref">[I-D.ietf-lpwan-overview]</a>.  However, some of these technologies do not support layer two fragmentation, therefore the only option for them to support the IPv6 MTU requirement of 1280 bytes <a href="#RFC2460" class="xref">[RFC2460]</a> is the use of a fragmentation protocol at the adaptation layer below IPv6.  This draft defines also a fragmentation functionality to support the IPv6 MTU requirements over LPWAN technologies. Such functionality has been designed under the assumption that data unit reordering will not happen between the entity performing fragmentation and the entity performing reassembly.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#LPWAN-Archi" id="LPWAN-Archi">LPWAN Architecture</a>
</h1>
<p id="rfc.section.2.p.1">LPWAN technologies have similar architectures but different terminology. We can identify different types of entities in a typical LPWAN network, see <a href="#Fig-LPWANarchi" class="xref">Figure 1</a>:</p>
<p id="rfc.section.2.p.2">o  Devices (Dev) are the end-devices or hosts (e.g. sensors, actuators, etc.). There can be a high density of devices per radio gateway.</p>
<p id="rfc.section.2.p.3">o  The Radio Gateway (RG), which is the end point of the constrained link.</p>
<p id="rfc.section.2.p.4">o  The Network Gateway (NGW) is the interconnection node between the Radio Gateway and the Internet.</p>
<p id="rfc.section.2.p.5">o  LPWAN-AAA Server, which controls the user authentication and the applications. We use the term LPWAN-AAA server because we are not assuming that this entity speaks RADIUS or Diameter as many/most AAA servers do, but equally we don&#8217;t want to rule that out, as the functionality will be similar.</p>
<p id="rfc.section.2.p.6">o  Application Server (App)</p>
<div id="rfc.figure.1"></div>
<div id="Fig-LPWANarchi"></div>
<pre>
                                              +------+
 ()   ()   ()       |                         |LPWAN-|
  ()  () () ()     / \         +---------+    | AAA  |
() () () () () ()  /   \=======|    ^    |====|Server|  +-----------+
 ()  ()   ()     |             | &lt;--|--&gt; |    +------+  |APPLICATION|
()  ()  ()  ()  / \============|    v    |==============|    (App)  |
  ()  ()  ()   /   \           +---------+              +-----------+
 Dev        Radio Gateways         NGW

</pre>
<p class="figure">Figure 1: LPWAN Architecture</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.3.p.1">This section defines the terminology and acronyms used in this document.</p>
<p></p>

<ul>
<li>App: LPWAN Application. An application sending/receiving IPv6 packets to/from the Device.</li>
<li>APP-IID: Application Interface Identifier. Second part of the IPv6 address to identify the application interface</li>
<li>Bi: Bidirectional, it can be used in both senses</li>
<li>CDA: Compression/Decompression Action. An action that is perfomed for both functionnalities to compress a header field or to recover its original value in the decompression phase.</li>
<li>Context: A set of rules used to compress/decompress headers</li>
<li>Dev: Device. Node connected to the LPWAN. A Dev may implement SCHC.</li>
<li>Dev-IID: Device Interface Identifier. Second part of the IPv6 address to identify the device interface</li>
<li>DI: Direction Indicator is a differentiator for matching in order to be able to have different values for both sides.</li>
<li>Dw: Down Link direction for compression, from SCHC C/D to Dev</li>
<li>FID: Field Indentifier is an index to describe the header fields in the Rule</li>
<li>FP: Field Position is a list of possible correct values that a field may use</li>
<li>IID: Interface Identifier. See the IPv6 addressing architecture <a href="#RFC7136" class="xref">[RFC7136]</a>
</li>
<li>MO: Matching Operator. An operator used to match a value contained in a header field with a value contained in a Rule.</li>
<li>Rule: A set of header field values.</li>
<li>Rule ID: An identifier for a rule, SCHC C/D and Dev share the same Rule ID for a specific flow.</li>
<li>SCHC C/D: Static Context Header Compression Compressor/Decompressor. A process in the network to achieve compression/decompressing headers. SCHC C/D uses SCHC rules to perform compression and decompression.</li>
<li>TV: Target value. A value contained in the Rule that will be matched with the value of a header field.</li>
<li>Up: Up Link direction for compression, from Dev to SCHC C/D</li>
</ul>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#static-context-header-compression" id="static-context-header-compression">Static Context Header Compression</a>
</h1>
<p id="rfc.section.4.p.1">Static Context Header Compression (SCHC) avoids context synchronization, which is the most bandwidth-consuming operation in other header compression mechanisms such as RoHC <a href="#RFC5795" class="xref">[RFC5795]</a>. Based on the fact that the nature of data flows is highly predictable in LPWAN networks, a static context may be stored on the Device (Dev). The context must be stored in both ends, and it can either be learned by a provisioning protocol or by out of band means or it can be pre-provosioned, etc.  The way the context is learned on both sides is out of the scope of this document.</p>
<div id="rfc.figure.2"></div>
<div id="Fig-archi"></div>
<pre>
     Dev                                                 App
+---------------+                                  +---------------+
| APP1 APP2 APP3|                                  |APP1  APP2 APP3|
|               |                                  |               |
|       UDP     |                                  |      UDP      | 
|      IPv6     |                                  |     IPv6      |   
|               |                                  |               |  
|    SCHC C/D   |                                  |               |  
|    (context)  |                                  |               | 
+--------+------+                                  +-------+-------+ 
         |   +--+     +----+     +---------+               .
         +~~ |RG| === |NGW | === |SCHC C/D |... Internet ...
             +--+     +----+     |(context)| 
                                 +---------+
</pre>
<p class="figure">Figure 2: Architecture</p>
<p><a href="#Fig-archi" class="xref">Figure 2</a> based on <a href="#I-D.ietf-lpwan-overview" class="xref">[I-D.ietf-lpwan-overview]</a> terminology represents the architecture for compression/decompression. The Device is sending applications flows using IPv6 or IPv6/UDP protocols. These flows are compressed by an Static Context Header Compression Compressor/Decompressor (SCHC C/D) to reduce headers size. Resulting information is sent on a layer two (L2) frame to the LPWAN Radio Network to a Radio Gateway (RG) which forwards the frame to a Network Gateway (NGW).  The NGW sends the data to a SCHC C/D for decompression which shares the same rules with the Dev. The SCHC C/D can be located on the Network Gateway (NGW) or in another place as long as a tunnel is established between the NGW and the SCHC C/D. SCHC C/D in both sides must share the same set of Rules.  After decompression, the packet can be sent on the Internet to one or several LPWAN Application Servers (App).</p>
<p id="rfc.section.4.p.3">The SCHC C/D process is bidirectional, so the same principles can be applied in the other direction.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#schc-rules" id="schc-rules">SCHC Rules</a>
</h1>
<p id="rfc.section.4.1.p.1">The main idea of the SCHC compression scheme is to send the Rule id to the other end that match as much as possible the original packet values instead of sending known field values. When a value is known by both ends, it is not necessary sent through the LPWAN network.</p>
<p id="rfc.section.4.1.p.2">The context contains a list of rules (cf. <a href="#Fig-ctxt" class="xref">Figure 3</a>). Each Rule contains itself a list of fields descriptions composed of a field identifier (FID), a field position (FP), a direction indicator (DI), a target value (TV), a matching operator (MO) and a Compression/Decompression Action (CDA).</p>
<div id="rfc.figure.3"></div>
<div id="Fig-ctxt"></div>
<pre>
  /--------------------------------------------------------------\
  |                      Rule N                                  |
 /--------------------------------------------------------------\|
 |                    Rule i                                    ||
/--------------------------------------------------------------\||
|  (FID)         Rule 1                                        |||
|+-------+--+--+------------+-----------------+---------------+|||
||Field 1|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+------------+-----------------+---------------+|||
||Field 2|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+------------+-----------------+---------------+|||
||...    |..|..|   ...      | ...             | ...           ||||
|+-------+--+--+------------+-----------------+---------------+||/
||Field N|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|||
|+-------+--+--+------------+-----------------+---------------+|/
|                                                              |
\--------------------------------------------------------------/
</pre>
<p class="figure">Figure 3: Compression/Decompression Context</p>
<p id="rfc.section.4.1.p.3">The Rule does not describe the original packet format which must be known from the compressor/decompressor. The rule just describes the compression/decompression behavior for the header fields. In the rule, the description of the header field must be performed in the format packet order.</p>
<p id="rfc.section.4.1.p.4">The Rule describes also the compressed header fields which are transmitted regarding their position in the rule which is used for data serialization on the compressor side and data deserialization on the decompressor side.</p>
<p id="rfc.section.4.1.p.5">The Context describes the header fields and its values with the following entries:</p>
<p></p>

<ul>
<li>A Field ID (FID) is a unique value to define the header field.</li>
<li>A Field Position (FP) indicating if several instances of the field exist in the headers which one is targeted. The default position is 1</li>
<li>A direction indicator (DI) indicating the packet direction. Three values are possible:  <ul>
<li>UP LINK (Up) when the field or the value is only present in packets sent by the Dev to the App,</li>
<li>DOWN LINK (Dw) when the field or the value is only present in packet sent from the App to the Dev and</li>
<li>BIDIRECTIONAL (Bi) when the field or the value is present either upstream or downstream.</li>
</ul>
</li>
<li>A Target Value (TV) is the value used to make the comparison with the packet header field. The Target Value can be of any type (integer, strings,&#8230;).  For instance, it can be a single value or a more complex structure (array, list,&#8230;), such as a JSON or a CBOR structure.</li>
<li>A Matching Operator (MO) is the operator used to make the comparison between the Field Value and the Target Value. The Matching Operator may require some parameters. MO is only used during the compression phase.</li>
<li>A Compression Decompression Action (CDA) is used to describe the compression and the decompression process. The CDA may require some parameters, CDA are used in both compression and decompression phases.</li>
</ul>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#rule-id" id="rule-id">Rule ID</a>
</h1>
<p id="rfc.section.4.2.p.1">Rule IDs are sent between both compression/decompression elements. The size of the Rule ID is not specified in this document, it is implementation-specific and can vary regarding the LPWAN technology, the number of flows, among others.</p>
<p id="rfc.section.4.2.p.2">Some values in the Rule ID space may be reserved for goals other than header compression as fragmentation. (See <a href="#Frag" class="xref">Section 9</a>).</p>
<p id="rfc.section.4.2.p.3">Rule IDs are specific to a Dev. Two Devs may use the same Rule ID for different header compression. To identify the correct Rule ID, the SCHC C/D needs to combine the Rule ID with the Dev L2 identifier to find the appropriate Rule.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#packet-processing" id="packet-processing">Packet processing</a>
</h1>
<p id="rfc.section.4.3.p.1">The compression/decompression process follows several steps:</p>
<p></p>

<ul>
<li>compression Rule selection: The goal is to identify which Rule(s) will be used to compress the packet&#8217;s headers. When doing compression from Dw to Up the SCHC C/D needs to find the correct Rule to use by identifying its Dev-ID and the Rule-ID. In the Up situation only the Rule-ID is used.  The next step is to choose the fields by their direction, using the direction indicator (DI), so the fields that does not correspond to the appropiated DI will be excluded.  Next, then fields are identified according to their field identifier (FID) and field position (FP).  If the field position does not correspond then the Rule is not use and the SCHC take next Rule.  Once the DI and the FP correspond to the header information, each field&#8217;s value is then compared to the corresponding target value (TV) stored in the Rule for that specific field using the matching operator (MO).  If all the fields in the packet&#8217;s header satisfy all the matching operators (MOs) of a Rule (i.e. all results are True), the fields of the header are then processed according to the Compression/Decompession Actions (CDAs) and a compressed header is obtained. Otherwise the next rule is tested.  If no eligible rule is found, then the header must be sent without compression, in which case the fragmentation process must be required.</li>
<li>sending: The Rule ID is sent to the other end followed by information resulting from the compression of header fields, directly followed by the payload.  The product of field compression is sent in the order expressed in the Rule for the matching fields. The way the Rule ID is sent depends on the specific LPWAN layer two technology and will be specified in a specific document, and is out of the scope of this document.  For example, it can be either included in a Layer 2 header or sent in the first byte of the L2 payload. (cf. <a href="#Fig-FormatPckt" class="xref">Figure 4</a>).</li>
<li>decompression: In both directions, The receiver identifies the sender through its device-id (e.g. MAC address) and selects the appropriate Rule through the Rule ID. This Rule gives the compressed header format and associates these values to header fields.  It applies the CDA action to reconstruct the original header fields. The CDA application order can be different of the order given by the Rule. For instance Compute-* may be applied at end, after the other CDAs.  <br><br> If after using SCHC compression and adding the payload to the L2 frame the datagram is not multiple of 8 bits, padding may be used.</li>
</ul>
<div id="rfc.figure.4"></div>
<div id="Fig-FormatPckt"></div>
<pre>
   +--- ... ---+-------------- ... --------------+-------------+--...--+
   |  Rule ID  |Compressed Hdr Fields information|   payload   |padding|
   +--- ... ---+-------------- ... --------------+-------------+--...--+

</pre>
<p class="figure">Figure 4: LPWAN Compressed Format Packet</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#chap-MO" id="chap-MO">Matching operators</a>
</h1>
<p id="rfc.section.5.p.1">Matching Operators (MOs) are functions used by both SCHC C/D endpoints involved in the header compression/decompression. They are not typed and can be applied indifferently to integer, string or any other data type. The result of the operation can either be True or False. MOs are defined as follows:</p>
<p></p>

<ul>
<li>equal: A field value in a packet matches with a TV in a Rule if they are equal.</li>
<li>ignore: No check is done between a field value in a packet and a TV in the Rule. The result of the matching is always true.</li>
<li>MSB(length): A matching is obtained if the most significant bits of the length field value bits of the header are equal to the TV in the rule. The MSB Matching Operator needs a parameter, indicating the number of bits, to proceed to the matching.</li>
<li>match-mapping: The goal of mapping-sent is to reduce the size of a field by allocating a shorter value. The Target Value contains a list of values. Each value is idenfied by a short ID (or index).  This operator matches if a field value is equal to one of those target values.</li>
</ul>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#chap-CDA" id="chap-CDA">Compression Decompression Actions (CDA)</a>
</h1>
<p id="rfc.section.6.p.1">The Compression Decompression Actions (CDA) describes the action taken during the compression of headers fields, and inversely, the action taken by the decompressor to restore the original value.</p>
<div id="rfc.figure.5"></div>
<div id="Fig-function"></div>
<pre>
/--------------------+-------------+----------------------------\
|  Action            | Compression | Decompression              |
|                    |             |                            |
+--------------------+-------------+----------------------------+
|not-sent            |elided       |use value stored in ctxt    |
|value-sent          |send         |build from received value   |
|mapping-sent        |send index   |value from index on a table |
|LSB(length)         |send LSB     |TV OR received value        |
|compute-length      |elided       |compute length              |
|compute-checksum    |elided       |compute UDP checksum        |
|Deviid              |elided       |build IID from L2 Dev addr  |
|Appiid              |elided       |build IID from L2 App addr  |
\--------------------+-------------+----------------------------/

</pre>
<p class="figure">Figure 5: Compression and Decompression Functions</p>
<p><a href="#Fig-function" class="xref">Figure 5</a> sumarizes the basics functions defined to compress and decompress a field. The first column gives the action&#8217;s name. The second and third columns outlines the compression/decompression behavior.</p>
<p id="rfc.section.6.p.3">Compression is done in the rule order and compressed values are sent in that order in the compressed message. The receiver must be able to find the size of each compressed field which can be given by the rule or may be sent with the compressed header.</p>
<p id="rfc.section.6.p.4">If the field is identified as variable, then its size must be sent first using the following coding:</p>
<p></p>

<ul>
<li>If the size is between 0 and 14 bytes it is sent using 4 bits.</li>
<li>For values between 15 and 255, the first 4 bit sent are set to 1 and the size is sent using 8 bits.</li>
<li>For higher value, the first 12 bytes are set to 1 and the size is sent on 2 bytes.</li>
</ul>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#not-sent-cda" id="not-sent-cda">not-sent CDA</a>
</h1>
<p id="rfc.section.6.1.p.1">Not-sent function is generally used when the field value is specified in the rule and therefore known by the both Compressor and Decompressor. This action is generally used with the &#8220;equal&#8221; MO. If MO is &#8220;ignore&#8221;, there is a risk to have a decompressed field value different from the compressed field.</p>
<p id="rfc.section.6.1.p.2">The compressor does not send any value on the compressed header for the field on which compression is applied.</p>
<p id="rfc.section.6.1.p.3">The decompressor restores the field value with the target value stored in the matched rule.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#value-sent-cda" id="value-sent-cda">value-sent CDA</a>
</h1>
<p id="rfc.section.6.2.p.1">The value-sent action is generally used when the field value is not known by both Compressor and Decompressor.  The value is sent in the compressed message header. Both Compressor and Decompressor must know the size of the field, either implicitly (the size is known by both sides) or explicitly in the compressed header field by indicating the length. This function is generally used with the &#8220;ignore&#8221; MO.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#mapping-sent" id="mapping-sent">mapping-sent</a>
</h1>
<p id="rfc.section.6.3.p.1">mapping-sent is used to send a smaller index associated to the list of values in the Target Value. This function is used together with the &#8220;match-mapping&#8221; MO.</p>
<p id="rfc.section.6.3.p.2">The compressor looks in the TV to find the field value and send the corresponding index.  The decompressor uses this index to restore the field value.</p>
<p id="rfc.section.6.3.p.3">The number of bits sent is the minimal size to code all the possible indexes.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#lsb-cda" id="lsb-cda">LSB CDA</a>
</h1>
<p id="rfc.section.6.4.p.1">LSB action is used to avoid sendind the known part of the packet field header to the other end.  This action is used together with the &#8220;MSB&#8221; MO. A length can be specified in the rule to indicate how many bits have to be sent. If not length is specified, the number of bits sent are the field length minus the bits length specified in the MSB MO.</p>
<p id="rfc.section.6.4.p.2">The compressor sends the &#8220;length&#8221; Least Significant Bits. The decompressor combines the value received with the Target Value.</p>
<p id="rfc.section.6.4.p.3">If this action is made on a variable length field, the remaning size in byte has to be sent before.</p>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> <a href="#deviid-appiid-cda" id="deviid-appiid-cda">DEViid, APPiid CDA</a>
</h1>
<p id="rfc.section.6.5.p.1">These functions are used to process respectively the Dev and the App Interface Identifiers (Deviid and Appiid) of the IPv6 addresses. Appiid CDA is less common, since current LPWAN technologies frames contain a single address.</p>
<p id="rfc.section.6.5.p.2">The IID value may be computed from the Device ID present in the Layer 2 header. The computation is specific for each LPWAN technology and may depend on the Device ID size.</p>
<p id="rfc.section.6.5.p.3">In the downstream direction, these CDA may be used to determine the L2 addresses used by the LPWAN.</p>
<h1 id="rfc.section.6.6">
<a href="#rfc.section.6.6">6.6.</a> <a href="#compute-" id="compute-">Compute-*</a>
</h1>
<p id="rfc.section.6.6.p.1">Thes classes of functions are used by the decompressor to compute the compressed field value based on received information.  Compressed fields are elided during compression and reconstructed during decompression.</p>
<p></p>

<ul>
<li>compute-length: compute the length assigned to this field. For instance, regarding the field ID, this CDA may be used to compute IPv6 length or UDP length.</li>
<li>compute-checksum: compute a checksum from the information already received by the SCHC C/D.  This field may be used to compute UDP checksum.</li>
</ul>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#application-to-ipv6-and-udp-headers" id="application-to-ipv6-and-udp-headers">Application to IPv6 and UDP headers</a>
</h1>
<p id="rfc.section.7.p.1">This section lists the different IPv6 and UDP header fields and how they can be compressed.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#ipv6-version-field" id="ipv6-version-field">IPv6 version field</a>
</h1>
<p id="rfc.section.7.1.p.1">This field always holds the same value, therefore the TV is 6, the MO is &#8220;equal&#8221; and the &#8220;CDA &#8220;not-sent&#8221;&#8221;.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#ipv6-traffic-class-field" id="ipv6-traffic-class-field">IPv6 Traffic class field</a>
</h1>
<p id="rfc.section.7.2.p.1">If the DiffServ field identified by the rest of the rule do not vary and is known by both sides, the TV should contain this well-known value, the MO should be &#8220;equal&#8221; and the CDA must be &#8220;not-sent.</p>
<p id="rfc.section.7.2.p.2">If the DiffServ field identified by the rest of the rule varies over time or is not known by both sides, then there are two possibilities depending on the variability of the value, the first one is to do not compressed the field and sends the original value, or the second where the values can be computed by sending only the LSB bits:</p>
<p></p>

<ul>
<li>TV is not set to any value, MO is set to &#8220;ignore&#8221; and CDA is set to &#8220;value-sent&#8221;</li>
<li>TV contains a stable value, MO is MSB(X) and CDA is set to LSB</li>
</ul>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#flow-label-field" id="flow-label-field">Flow label field</a>
</h1>
<p id="rfc.section.7.3.p.1">If the Flow Label field identified by the rest of the rule does not vary and is known by both sides, the TV should contain this well-known value, the MO should be &#8220;equal&#8221; and the CDA should be &#8220;not-sent&#8221;.</p>
<p id="rfc.section.7.3.p.2">If the Flow Label field identified by the rest of the rule varies during time or is not known by both sides, there are two possibilities depending on the variability of the value, the first one is without compression and then the value is sent and the second where only part of the value is sent and the decompressor needs to compute the original value:</p>
<p></p>

<ul>
<li>TV is not set, MO is set to &#8220;ignore&#8221; and CDA is set to &#8220;value-sent&#8221;</li>
<li>TV contains a stable value, MO is MSB(X) and CDA is set to LSB</li>
</ul>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#payload-length-field" id="payload-length-field">Payload Length field</a>
</h1>
<p id="rfc.section.7.4.p.1">If the LPWAN technology does not add padding, this field can be elided for the transmission on the LPWAN network. The SCHC C/D recomputes the original payload length value. The TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is &#8220;compute-IPv6-length&#8221;.</p>
<p id="rfc.section.7.4.p.2">If the payload length needs to be sent and does not need to be coded in 16 bits, the TV can be set to 0x0000, the MO set to &#8220;MSB (16-s)&#8221; and the CDA to &#8220;LSB&#8221;. The &#8216;s&#8217; parameter depends on the expected maximum packet length.</p>
<p id="rfc.section.7.4.p.3">On other cases, the payload length field must be sent and the CDA is replaced by &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> <a href="#next-header-field" id="next-header-field">Next Header field</a>
</h1>
<p id="rfc.section.7.5.p.1">If the Next Header field identified by the rest of the rule does not vary and is known by both sides, the TV should contain this Next Header value, the MO should be &#8220;equal&#8221; and the CDA should be &#8220;not-sent&#8221;.</p>
<p id="rfc.section.7.5.p.2">If the Next header field identified by the rest of the rule varies during time or is not known by both sides, then TV is not set, MO is set to &#8220;ignore&#8221; and CDA is set to &#8220;value-sent&#8221;. A matching-list may also be used.</p>
<h1 id="rfc.section.7.6">
<a href="#rfc.section.7.6">7.6.</a> <a href="#hop-limit-field" id="hop-limit-field">Hop Limit field</a>
</h1>
<p id="rfc.section.7.6.p.1">The End System is generally a device and does not forward packets, therefore the Hop Limit value is constant. So the TV is set with a default value, the MO is set to &#8220;equal&#8221; and the CDA is set to &#8220;not-sent&#8221;.</p>
<p id="rfc.section.7.6.p.2">Otherwise the value is sent on the LPWAN: TV is not set, MO is set to ignore and CDA is set to &#8220;value-sent&#8221;.</p>
<p id="rfc.section.7.6.p.3">Note that the field behavior differs in upstream and downstream. In upstream, since there is no IP forwarding between the Dev and the SCHC C/D, the value is relatively constant. On the other hand, the downstream value depends of Internet routing and may change more frequently.  One solution could be to use the Direction Indicator (DI) to distinguish both directions to elide the field in the upstream direction and send the value in the downstream direction.</p>
<h1 id="rfc.section.7.7">
<a href="#rfc.section.7.7">7.7.</a> <a href="#ipv6-addresses-fields" id="ipv6-addresses-fields">IPv6 addresses fields</a>
</h1>
<p id="rfc.section.7.7.p.1">As in 6LoWPAN <a href="#RFC4944" class="xref">[RFC4944]</a>, IPv6 addresses are split into two 64-bit long fields; one for the prefix and one for the Interface Identifier (IID). These fields should be compressed. To allow a single rule, these values are identified by their role (DEV or APP) and not by their position in the frame (source or destination). The SCHC C/D must be aware of the traffic direction (upstream, downstream) to select the appropriate field.</p>
<h1 id="rfc.section.7.7.1">
<a href="#rfc.section.7.7.1">7.7.1.</a> <a href="#ipv6-source-and-destination-prefixes" id="ipv6-source-and-destination-prefixes">IPv6 source and destination prefixes</a>
</h1>
<p id="rfc.section.7.7.1.p.1">Both ends must be synchronized with the appropriate prefixes. For a specific flow, the source and destination prefix can be unique and stored in the context. It can be either a link-local prefix or a global prefix. In that case, the TV for the source and destination prefixes contains the values, the MO is set to &#8220;equal&#8221; and the CDA is set to &#8220;not-sent&#8221;.</p>
<p id="rfc.section.7.7.1.p.2">In case the rule allows several prefixes, mapping-list must be used. The different prefixes are listed in the TV associated with a short ID. The MO is set to &#8220;match-mapping&#8221; and the CDA is set to &#8220;mapping-sent&#8221;.</p>
<p id="rfc.section.7.7.1.p.3">Otherwise the TV contains the prefix, the MO is set to &#8220;equal&#8221; and the CDA is set to value-sent.</p>
<h1 id="rfc.section.7.7.2">
<a href="#rfc.section.7.7.2">7.7.2.</a> <a href="#ipv6-source-and-destination-iid" id="ipv6-source-and-destination-iid">IPv6 source and destination IID</a>
</h1>
<p id="rfc.section.7.7.2.p.1">If the DEV or APP IID are based on an LPWAN address, then the IID can be reconstructed with information coming from the LPWAN header. In that case, the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;DEViid&#8221; or &#8220;APPiid&#8221;. Note that the LPWAN technology is generally carrying a single device identifier corresponding to the DEV. The SCHC C/D may also not be aware of these values.</p>
<p id="rfc.section.7.7.2.p.2">If the DEV address has a static value that is not derivated from an IEEE EUI-64, then TV contains the actual Dev address value, the MO operator is set to &#8220;equal&#8221; and the CDA is set to &#8220;not-sent&#8221;.</p>
<p id="rfc.section.7.7.2.p.3">If several IIDs are possible, then the TV contains the list of possible IIDs, the MO is set to &#8220;match-mapping&#8221; and the CDA is set to &#8220;mapping-sent&#8221;.</p>
<p id="rfc.section.7.7.2.p.4">Otherwise the value variation of the IID may be reduced to few bytes. In that case, the TV is set to the stable part of the IID, the MO is set to MSB and the CDA is set to LSB.</p>
<p id="rfc.section.7.7.2.p.5">Finally, the IID can be sent on the LPWAN. In that case, the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.7.8">
<a href="#rfc.section.7.8">7.8.</a> <a href="#ipv6-extensions" id="ipv6-extensions">IPv6 extensions</a>
</h1>
<p id="rfc.section.7.8.p.1">No extension rules are currently defined. They can be based on the MOs and CDAs described above.</p>
<h1 id="rfc.section.7.9">
<a href="#rfc.section.7.9">7.9.</a> <a href="#udp-source-and-destination-port" id="udp-source-and-destination-port">UDP source and destination port</a>
</h1>
<p id="rfc.section.7.9.p.1">To allow a single rule, the UDP port values are identified by their role (DEV or APP) and not by their position in the frame (source or destination). The SCHC C/D must be aware of the traffic direction (upstream, downstream) to select the appropriate field. The following rules apply for DEV and APP port numbers.</p>
<p id="rfc.section.7.9.p.2">If both ends know the port number, it can be elided. The TV contains the port number, the MO is set to &#8220;equal&#8221; and the CDA is set to &#8220;not-sent&#8221;.</p>
<p id="rfc.section.7.9.p.3">If the port variation is on few bits, the TV contains the stable part of the port number, the MO is set to &#8220;MSB&#8221; and the CDA is set to &#8220;LSB&#8221;.</p>
<p id="rfc.section.7.9.p.4">If some well-known values are used,  the TV can contain the list of this values, the MO is set to &#8220;match-mapping&#8221; and the CDA is set to &#8220;mapping-sent&#8221;.</p>
<p id="rfc.section.7.9.p.5">Otherwise the port numbers are sent on the LPWAN. The TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.7.10">
<a href="#rfc.section.7.10">7.10.</a> <a href="#udp-length-field" id="udp-length-field">UDP length field</a>
</h1>
<p id="rfc.section.7.10.p.1">If the LPWAN technology does not introduce padding, the UDP length can be computed from the received data. In that case the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;compute-UDP-length&#8221;.</p>
<p id="rfc.section.7.10.p.2">If the payload is small, the TV can be set to 0x0000, the MO set to &#8220;MSB&#8221; and the CDA to &#8220;LSB&#8221;.</p>
<p id="rfc.section.7.10.p.3">On other cases, the length must be sent and the CDA is replaced by &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.7.11">
<a href="#rfc.section.7.11">7.11.</a> <a href="#udp-checksum-field" id="udp-checksum-field">UDP Checksum field</a>
</h1>
<p id="rfc.section.7.11.p.1">IPv6 mandates a checksum in the protocol above IP. Nevertheless, if a more efficient mechanism such as L2 CRC or MIC is carried by or over the L2 (such as in the LPWAN fragmentation process (see section <a href="#Frag" class="xref">Section 9</a>)), the UDP checksum transmission can be avoided.  In that case, the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;compute-UDP-checksum&#8221;.</p>
<p id="rfc.section.7.11.p.2">In other cases the checksum must be explicitly sent. The TV is not set, the MO is set to &#8220;ignore&#8221; and the CDF is set to &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#compressIPv6" id="compressIPv6">Examples</a>
</h1>
<p id="rfc.section.8.p.1">This section gives some scenarios of the compression mechanism for IPv6/UDP.  The goal is to illustrate the SCHC behavior.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#ipv6udp-compression" id="ipv6udp-compression">IPv6/UDP compression</a>
</h1>
<p id="rfc.section.8.1.p.1">The most common case using the mechanisms defined in this document will be a LPWAN Dev that embeds some applications running over CoAP. In this example, three flows are considered. The first flow is for the device management based on CoAP using Link Local IPv6 addresses and UDP ports 123 and 124 for Dev and App, respectively.  The second flow will be a CoAP server for measurements done by the Device (using ports 5683) and Global IPv6 Address prefixes alpha::IID/64 to beta::1/64.  The last flow is for legacy applications using different ports numbers, the destination IPv6 address prefix is gamma::1/64.</p>
<p><a href="#FigStack" class="xref">Figure 6</a> presents the protocol stack for this Device. IPv6 and UDP are represented with dotted lines since these protocols are compressed on the radio link.</p>
<div id="rfc.figure.6"></div>
<div id="FigStack"></div>
<pre>
 Managment    Data
+----------+---------+---------+
|   CoAP   |  CoAP   | legacy  |
+----||----+---||----+---||----+
.   UDP    .  UDP    |   UDP   |
................................
.   IPv6   .  IPv6   .  IPv6   .
+------------------------------+
|    SCHC Header compression   |
|      and fragmentation       |
+------------------------------+
|      LPWAN L2 technologies   |
+------------------------------+
         DEV or NGW

</pre>
<p class="figure">Figure 6: Simplified Protocol Stack for LP-WAN</p>
<p id="rfc.section.8.1.p.3">Note that in some LPWAN technologies, only the Devs have a device ID.  Therefore, when such technologies are used, it is necessary to define statically an IID for the Link Local address for the SCHC C/D.</p>
<div id="rfc.figure.7"></div>
<div id="Fig-fields"></div>
<pre>
  Rule 0
  +----------------+--+--+---------+--------+-------------++------+
  | Field          |FP|DI| Value   | Match  | Comp Decomp || Sent |
  |                |  |  |         | Opera. | Action      ||[bits]|
  +----------------+--+--+---------+----------------------++------+
  |IPv6 version    |1 |Bi|6        | equal  | not-sent    ||      |
  |IPv6 DiffServ   |1 |Bi|0        | equal  | not-sent    ||      |
  |IPv6 Flow Label |1 |Bi|0        | equal  | not-sent    ||      |
  |IPv6 Length     |1 |Bi|         | ignore | comp-length ||      |
  |IPv6 Next Header|1 |Bi|17       | equal  | not-sent    ||      |
  |IPv6 Hop Limit  |1 |Bi|255      | ignore | not-sent    ||      |
  |IPv6 DEVprefix  |1 |Bi|FE80::/64| equal  | not-sent    ||      |
  |IPv6 DEViid     |1 |Bi|         | ignore | DEViid      ||      |
  |IPv6 APPprefix  |1 |Bi|FE80::/64| equal  | not-sent    ||      |
  |IPv6 APPiid     |1 |Bi|::1      | equal  | not-sent    ||      |
  +================+==+==+=========+========+=============++======+
  |UDP DEVport     |1 |Bi|123      | equal  | not-sent    ||      |
  |UDP APPport     |1 |Bi|124      | equal  | not-sent    ||      |
  |UDP Length      |1 |Bi|         | ignore | comp-length ||      |
  |UDP checksum    |1 |Bi|         | ignore | comp-chk    ||      |
  +================+==+==+=========+========+=============++======+

  Rule 1
  +----------------+--+--+---------+--------+-------------++------+
  | Field          |FP|DI| Value   | Match  | Action      || Sent |
  |                |  |  |         | Opera. | Action      ||[bits]|
  +----------------+--+--+---------+--------+-------------++------+
  |IPv6 version    |1 |Bi|6        | equal  | not-sent    ||      |
  |IPv6 DiffServ   |1 |Bi|0        | equal  | not-sent    ||      |
  |IPv6 Flow Label |1 |Bi|0        | equal  | not-sent    ||      |
  |IPv6 Length     |1 |Bi|         | ignore | comp-length ||      |
  |IPv6 Next Header|1 |Bi|17       | equal  | not-sent    ||      |
  |IPv6 Hop Limit  |1 |Bi|255      | ignore | not-sent    ||      |
  |IPv6 DEVprefix  |1 |Bi|[alpha/64, match- | mapping-sent||  [1] |
  |                |1 |Bi|fe80::/64] mapping|             ||      |
  |IPv6 DEViid     |1 |Bi|         | ignore | DEViid      ||      |
  |IPv6 APPprefix  |1 |Bi|[beta/64,| match- | mapping-sent||  [2] |
  |                |  |  |alpha/64,| mapping|             ||      |
  |                |  |  |fe80::64]|        |             ||      |
  |IPv6 APPiid     |1 |Bi|::1000   | equal  | not-sent    ||      |
  +================+==+==+=========+========+=============++======+
  |UDP DEVport     |1 |Bi|5683     | equal  | not-sent    ||      |
  |UDP APPport     |1 |Bi|5683     | equal  | not-sent    ||      |
  |UDP Length      |1 |Bi|         | ignore | comp-length ||      |
  |UDP checksum    |1 |Bi|         | ignore | comp-chk    ||      |
  +================+==+==+=========+========+=============++======+

  Rule 2
  +----------------+--+--+---------+--------+-------------++------+
  | Field          |FP|DI| Value   | Match  | Action      || Sent |
  |                |  |  |         | Opera. | Action      ||[bits]|
  +----------------+--+--+---------+--------+-------------++------+
  |IPv6 version    |1 |Bi|6        | equal  | not-sent    ||      |
  |IPv6 DiffServ   |1 |Bi|0        | equal  | not-sent    ||      |
  |IPv6 Flow Label |1 |Bi|0        | equal  | not-sent    ||      |
  |IPv6 Length     |1 |Bi|         | ignore | comp-length ||      |
  |IPv6 Next Header|1 |Bi|17       | equal  | not-sent    ||      |
  |IPv6 Hop Limit  |1 |Up|255      | ignore | not-sent    ||      |
  |IPv6 Hop Limit  |1 |Dw|         | ignore | value-sent  ||  [8] |
  |IPv6 DEVprefix  |1 |Bi|alpha/64 | equal  | not-sent    ||      |
  |IPv6 DEViid     |1 |Bi|         | ignore | DEViid      ||      |
  |IPv6 APPprefix  |1 |Bi|gamma/64 | equal  | not-sent    ||      |
  |IPv6 APPiid     |1 |Bi|::1000   | equal  | not-sent    ||      |
  +================+==+==+=========+========+=============++======+
  |UDP DEVport     |1 |Bi|8720     | MSB(12)| LSB(4)      || [4]  |
  |UDP APPport     |1 |Bi|8720     | MSB(12)| LSB(4)      || [4]  |
  |UDP Length      |1 |Bi|         | ignore | comp-length ||      |
  |UDP checksum    |1 |Bi|         | ignore | comp-chk    ||      |
  +================+==+==+=========+========+=============++======+


</pre>
<p class="figure">Figure 7: Context rules</p>
<p id="rfc.section.8.1.p.4">All the fields described in the three rules depicted on <a href="#Fig-fields" class="xref">Figure 7</a> are present in the IPv6 and UDP headers.  The DEViid-DID value is found in the L2 header.</p>
<p id="rfc.section.8.1.p.5">The second and third rules use global addresses. The way the Dev learns the prefix is not in the scope of the document.</p>
<p id="rfc.section.8.1.p.6">The third rule compresses port numbers to 4 bits.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#Frag" id="Frag">Fragmentation</a>
</h1>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#overview" id="overview">Overview</a>
</h1>
<p id="rfc.section.9.1.p.1">Fragmentation support in LPWAN is mandatory when the underlying LPWAN technology is not capable of fulfilling the IPv6 MTU requirement. Fragmentation is used if, after SCHC header compression, the size of the resulting IPv6 packet is larger than the L2 data unit maximum payload. Fragmentation is also used if SCHC header compression has not been able to compress an IPv6 packet that is larger than the L2 data unit maximum payload. In LPWAN technologies, the L2 data unit size typically varies from tens to hundreds of bytes.  If the entire IPv6 datagram fits within a single L2 data unit, the fragmentation mechanism is not used and the packet is sent unfragmented.<br> If the datagram does not fit within a single L2 data unit, it SHALL be broken into fragments.</p>
<p id="rfc.section.9.1.p.2">Moreover, LPWAN technologies impose some strict limitations on traffic; therefore it is desirable to enable optional fragment retransmission, while a single fragment loss should not lead to retransmitting the full IPv6 datagram.  On the other hand, in order to preserve energy, Devices are sleeping most of the time and may receive data during a short period of time after transmission. In order to adapt to the capabilities of various LPWAN technologies, this specification allows for a gradation of fragment delivery reliability. This document does not make any decision with regard to which fragment delivery reliability option is used over a specific LPWAN technology.</p>
<p id="rfc.section.9.1.p.3">An important consideration is that LPWAN networks typically follow the star topology, and therefore data unit reordering is not expected in such networks. This specification assumes that reordering will not happen between the entity performing fragmentation and the entity performing reassembly. This assumption allows to reduce complexity and overhead of the fragmentation mechanism.</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#reliability-options-definition" id="reliability-options-definition">Reliability options: definition</a>
</h1>
<p id="rfc.section.9.2.p.1">This specification defines the following three fragment delivery reliability options:</p>
<p id="rfc.section.9.2.p.2">o  No ACK</p>
<p id="rfc.section.9.2.p.3">o  Window mode - ACK &#8220;always&#8221;</p>
<p id="rfc.section.9.2.p.4">o  Window mode - ACK on error</p>
<p id="rfc.section.9.2.p.5">The same reliability option MUST be used for all fragments of a packet. It is up to implementers and/or representatives of the underlying LPWAN technology to decide which reliability option to use and whether the same reliability option applies to all IPv6 packets or not.  Note that the reliability option to be used is not necessarily tied to the particular characteristics of the underlying L2 LPWAN technology (e.g. the No ACK reliability option may be used on top of an L2 LPWAN technology with symmetric characteristics for uplink and downlink).</p>
<p id="rfc.section.9.2.p.6">In the No ACK option, the receiver MUST NOT issue acknowledgments (ACK).</p>
<p id="rfc.section.9.2.p.7">In Window mode &#8211; ACK &#8220;always&#8221;, an ACK is transmitted by the fragment receiver after a window of fragments have been sent.  A window of fragments is a subset of the full set of fragments needed to carry an IPv6 packet.  In this mode, the ACK informs the sender about received and/or missing fragments from the window of fragments. Upon receipt of an ACK that informs about any lost fragments, the sender retransmits the lost fragments, as long as a maximum of MAX_FRAG_RETRIES is not exceeded for each one of those fragments. The default value of MAX_FRAG_RETRIES is not stated in this document, and it is expected to be defined in other documents (e.g. technology- specific profiles).</p>
<p id="rfc.section.9.2.p.8">In Window mode &#8211; ACK on error, an ACK is transmitted by the fragment receiver after a window of fragments have been sent, only if at least one of the fragments in the window has been lost. In this mode, the ACK informs the sender about received and/or missing fragments from the window of fragments. Upon receipt of an ACK that informs about any lost fragments, the sender retransmits the lost fragments.  The maximum number of ACKs to be sent by the receiver for a specific window, denoted MAX_ACKS_PER_WINDOW, is not stated in this document, and it is expected to be defined in other documents (e.g. technology- specific profiles).</p>
<p id="rfc.section.9.2.p.9">This document does not make any decision as to which fragment delivery reliability option(s) need to be supported over a specific LPWAN technology.</p>
<p id="rfc.section.9.2.p.10">Examples of the different reliability options described are provided in Appendix A.</p>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#reliability-options-discussion" id="reliability-options-discussion">Reliability options: discussion</a>
</h1>
<p id="rfc.section.9.3.p.1">This section discusses the properties of each fragment delivery reliability option defined in the previous section.</p>
<p id="rfc.section.9.3.p.2">No ACK is the most simple fragment delivery reliability option. With this option, the receiver does not generate overhead in the form of ACKs.  However, this option does not enhance delivery reliability beyond that offered by the underlying LPWAN technology.</p>
<p id="rfc.section.9.3.p.3">The Window mode - ACK on error option is based on the optimistic expectation that the underlying links will offer relatively low L2 data unit loss probability. This option reduces the number of ACKs transmitted by the fragment receiver compared to the Window mode - ACK &#8220;always&#8221; option. This may be especially beneficial in asymmetric scenarios, e.g. where fragmented data are sent uplink and the underlying LPWAN technology downlink capacity or message rate is lower than the uplink one. However, if an ACK is lost, the sender assumes that all fragments covered by the ACK have been successfully delivered. In contrast, the Window mode - ACK &#8220;always&#8221; option does not suffer that issue, at the expense of an ACK overhead increase.</p>
<p id="rfc.section.9.3.p.4">The Window mode &#8211; ACK &#8220;always&#8221; option provides flow control. In addition, it is able to handle long bursts of lost fragments, since detection of such events can be done before end of the IPv6 packet transmission, as long as the window size is short enough. However, such benefit comes at the expense of higher ACK overhead.</p>
<h1 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> <a href="#tools" id="tools">Tools</a>
</h1>
<p id="rfc.section.9.4.p.1">This subsection describes the different tools that are used to enable the described fragmentation functionality and the different reliability options supported. Each tool has a corresponding header field format that is defined in the next subsection. The list of tools follows:</p>
<p id="rfc.section.9.4.p.2">o  Rule ID. The Rule ID is used in fragments and in ACKs. The Rule ID in a fragment is set to a value that indicates that the data unit being carried is a fragment. This also allows to interleave non-fragmented IPv6 datagrams with fragments that carry a larger IPv6 datagram. Rule ID may also be used to signal which reliability option is in use for the IPv6 packet being carried. In an ACK, the Rule ID signals that the message this Rule ID is prepended to is an ACK.</p>
<p id="rfc.section.9.4.p.3">o  Compressed Fragment Number (CFN). The CFN is included in all fragments. This field can be understood as a truncated, efficient representation of a larger-sized fragment number, and does not necessarily carry an absolute fragment number. A special CFN value signals the last fragment that carries a fragmented IPv6 packet. In Window mode, the CFN is augmented with the W bit, which has the purpose of avoiding possible ambiguity for the receiver that might arise under certain conditions</p>
<p id="rfc.section.9.4.p.4">o  Datagram Tag (DTag). The DTag field, if present, is set to the same value for all fragments carrying the same IPv6 datagram, allows to interleave fragments that correspond to different IPv6 datagrams.</p>
<p id="rfc.section.9.4.p.5">o  Message Integrity Check (MIC). It is computed by the sender over the complete IPv6 packet before fragmentation by using the TBD algorithm. The MIC allows the receiver to check for errors in the reassembled IPv6 packet, while it also enables compressing the UDP checksum by use of SCHC.</p>
<p id="rfc.section.9.4.p.6">o  Bitmap. The bitmap is a sequence of bits included in the ACK for a given window, that provides feedback on whether each fragment of the current window has been received or not.</p>
<h1 id="rfc.section.9.5">
<a href="#rfc.section.9.5">9.5.</a> <a href="#formats" id="formats">Formats</a>
</h1>
<p id="rfc.section.9.5.p.1">This section defines the fragment format, the fragmentation header formats, and the ACK format.</p>
<h1 id="rfc.section.9.5.1">
<a href="#rfc.section.9.5.1">9.5.1.</a> <a href="#fragment-format" id="fragment-format">Fragment format</a>
</h1>
<p id="rfc.section.9.5.1.p.1">A fragment comprises a fragmentation header and a fragment payload, and conforms to the format shown in <a href="#Fig-FragFormat" class="xref">Figure 8</a>. The fragment payload carries a subset of either the IPv6 packet after header compression or an IPv6 packet which could not be compressed.  A fragment is the payload in the L2 protocol data unit (PDU).</p>
<div id="rfc.figure.8"></div>
<div id="Fig-FragFormat"></div>
<pre>
      +---------------+-----------------------+
      | Fragm. Header |   Fragment payload    |
      +---------------+-----------------------+
</pre>
<p class="figure">Figure 8: Fragment format.</p>
<h1 id="rfc.section.9.5.2">
<a href="#rfc.section.9.5.2">9.5.2.</a> <a href="#fragmentation-header-formats" id="fragmentation-header-formats">Fragmentation header formats</a>
</h1>
<p id="rfc.section.9.5.2.p.1">In the No ACK option, fragments except the last one SHALL contain the fragmentation header as defined in <a href="#Fig-NotLast" class="xref">Figure 9</a>. The total size of this fragmentation header is R bits.</p>
<div id="rfc.figure.9"></div>
<div id="Fig-NotLast"></div>
<pre>
             &lt;------------ R ----------&gt;
                         &lt;--T--&gt; &lt;--N--&gt;
             +-- ... --+- ...  -+- ... -+
             | Rule ID |  DTag  |  CFN  |
             +-- ... --+- ...  -+- ... -+

</pre>
<p class="figure">Figure 9: Fragmentation Header for Fragments except the Last One, No ACK option</p>
<p id="rfc.section.9.5.2.p.2">In any of the Window mode options, fragments except the last one SHALL  <br> contain the fragmentation header as defined in <a href="#Fig-NotLastWin" class="xref">Figure 10</a>. The total size of this fragmentation header is R bits.</p>
<div id="rfc.figure.10"></div>
<div id="Fig-NotLastWin"></div>
<pre>
             &lt;------------ R ----------&gt;
                       &lt;--T--&gt; 1 &lt;--N--&gt;
            +-- ... --+- ... -+-+- ... -+
            | Rule ID | DTag  |W|  CFN  |
            +-- ... --+- ... -+-+- ... -+

</pre>
<p class="figure">Figure 10: Fragmentation Header for Fragments except the Last One, Window mode</p>
<p id="rfc.section.9.5.2.p.3">In the No ACK option, the last fragment of an IPv6 datagram SHALL contain a fragmentation header that conforms to the format shown in <a href="#Fig-Last" class="xref">Figure 11</a>. The total size of this fragmentation header is R+M bits.</p>
<div id="rfc.figure.11"></div>
<div id="Fig-Last"></div>
<pre>
              &lt;------------- R ------------&gt;
                            &lt;- T -&gt; &lt;- N -&gt; &lt;---- M -----&gt;
              +---- ... ---+- ... -+- ... -+---- ... ----+
              |   Rule ID  | DTag  | 11..1 |     MIC     |
              +---- ... ---+- ... -+- ... -+---- ... ----+
</pre>
<p class="figure">Figure 11: Fragmentation Header for the Last Fragment, No ACK option</p>
<p id="rfc.section.9.5.2.p.4">In any of the Window modes, the last fragment of an IPv6 datagram SHALL contain a fragmentation header that conforms to the format shown in <a href="#Fig-LastWinMode" class="xref">Figure 12</a>. The total size of this fragmentation header is R+M bits.</p>
<div id="rfc.figure.12"></div>
<div id="Fig-LastWinMode"></div>
<pre>
              &lt;------------ R ------------&gt;
                         &lt;- T -&gt; 1 &lt;- N -&gt; &lt;---- M -----&gt;
              +-- ... --+- ... -+-+- ... -+---- ... ----+
              | Rule ID | DTag  |W| 11..1 |     MIC     |
              +-- ... --+- ... -+-+- ... -+---- ... ----+
</pre>
<p class="figure">Figure 12: Fragmentation Header for the Last Fragment, Window mode</p>
<p></p>

<ul>
<li>Rule ID: This field has a size of R - T - N - 1 bits when Window mode is used. In No ACK mode, the Rule ID field has a size of R &#8211; T &#8211; N bits.</li>
<li>DTag: The size of the DTag field is T bits, which may be set to a value greater than or equal to 0 bits. The DTag field in all fragments that carry the same IPv6 datagram MUST be set to the same value. DTag MUST be set sequentially increasing from 0 to 2^T - 1, and MUST wrap back from 2^T - 1 to 0.</li>
<li>CFN: This field is an unsigned integer, with a size of N bits, that carries the CFN of the fragment. In the No ACK option, N=1. For the rest of options, N equal to or greater than 3 is recommended. The CFN MUST be set sequentially decreasing from the highest CFN in the window (which will be used for the first fragment), and MUST wrap from 0 back to the highest CFN in the window. The highest CFN in the window MUST be a value equal to or smaller than 2^N-2. (Example 1: for N=5, the highest CFN value may be configured to be 30, then subsequent CFNs are set sequentially and in decreasing order, and CFN will wrap from 0 back to 30. Example 2: for N=5, the highest CFN value may be set to 23, then subsequent CFNs are set sequentially and in decreasing order, and the CFN will wrap from 0 back to 23). The CFN for the last fragment has all bits set to 1. Note that, by this definition, the CFN value of 2^N - 1 is only used to identify a fragment as the last fragment carrying a subset of the IPv6 packet being transported, and thus the CFN does not strictly correspond to the N least significant bits of the actual absolute fragment number. It is also important to note that, for N=1, the last fragment of the packet will carry a CFN equal to 1, while all previous fragments will carry a CFN of 0.</li>
<li>W: W is a 1-bit field. This field carries the same value for all fragments of a window, and it is complemented for the next window. The initial value for this field is 1.</li>
<li>MIC: This field, which has a size of M bits, carries the MIC for the IPv6 packet.</li>
</ul>
<p id="rfc.section.9.5.2.p.6">The values for R, N, T and M are not specified in this document, and have to be determined in other documents (e.g. technology-specific profile documents).</p>
<h1 id="rfc.section.9.5.3">
<a href="#rfc.section.9.5.3">9.5.3.</a> <a href="#ack-format" id="ack-format">ACK format</a>
</h1>
<p id="rfc.section.9.5.3.p.1">The format of an ACK is shown in <a href="#Fig-ACK-Format" class="xref">Figure 13</a>:</p>
<div id="rfc.figure.13"></div>
<div id="Fig-ACK-Format"></div>
<pre>
                &lt;--------  R  -------&gt;
                            &lt;- T -&gt; 1  
                +---- ... --+-... -+-+----- ... ---+
                |  Rule ID  | DTag |W|   bitmap    |
                +---- ... --+-... -+-+----- ... ---+
</pre>
<p class="figure">Figure 13: Format of an ACK</p>
<p id="rfc.section.9.5.3.p.2">Rule ID: In all ACKs, Rule ID has a size of R - T - 1 bits.</p>
<p id="rfc.section.9.5.3.p.3">DTag: DTag has a size of T bits. DTag carries the same value as the DTag field in the fragments carrying the IPv6 datagram for which this ACK is intended.</p>
<p id="rfc.section.9.5.3.p.4">W: This field has a size of 1 bit. In all ACKs, the W bit carries the same value as the W bit carried by the fragments whose reception is being positively or negatively acknowledged by the ACK.</p>
<p id="rfc.section.9.5.3.p.5">bitmap: This field carries the bitmap sent by the receiver to inform the sender about whether fragments in the current window have been received or not. Size of the bitmap field of an ACK can be equal to 0 or Ceiling(Number_of_Fragments/8) octets, where Number_of_Fragments denotes the number of fragments of a window. The bitmap is a sequence of bits, where the n-th bit signals whether the n-th fragment transmitted in the current window has been correctly received (n-th bit set to 1) or not (n-th bit set to 0). Remaining bits with bit order greater than the number of fragments sent (as determined by the receiver) are set to 0, except for the last bit in the bitmap, which is set to 1 if the last fragment of the window has been correctly received, and 0 otherwise. Feedback on reception of the fragment with CFN = 2^N - 1 (last fragment carrying an IPv6 packet) is only given by the last bit of the corresponding bitmap. Absence of the bitmap in an ACK confirms correct reception of all fragments to be acknowledged by means of the ACK.</p>
<p><a href="#Fig-Bitmap-Win" class="xref">Figure 14</a> shows an example of an ACK (N=3), where the bitmap indicates that the second and the fifth fragments have not been correctly received.</p>
<div id="rfc.figure.14"></div>
<div id="Fig-Bitmap-Win"></div>
<pre>
              &lt;-------   R  -------&gt;
                          &lt;- T -&gt;   0 1 2 3 4 5 6 7
              +---- ... --+-... -+-+-+-+-+-+-+-+-+-+
              |  Rule ID  | DTag |W|1|0|1|1|0|1|1|1|
              +---- ... --+-... -+-+-+-+-+-+-+-+-+-+

</pre>
<p class="figure">Figure 14: Example of the bitmap in an ACK (in Window mode, for N=3)</p>
<p><a href="#Fig-NoBitmap" class="xref">Figure 15</a> illustrates an ACK without a bitmap.</p>
<div id="rfc.figure.15"></div>
<div id="Fig-NoBitmap"></div>
<pre>
                    &lt;-------   R  -------&gt;
                                &lt;- T -&gt; 
                    +---- ... --+-... -+-+
                    |  Rule ID  | DTag |W|
                    +---- ... --+-... -+-+

</pre>
<p class="figure">Figure 15: Example of an ACK without a bitmap</p>
<p id="rfc.section.9.5.3.p.8">Note that, in order to exploit the available L2 payload space to the fullest, a bitmap may have a size smaller than 2^N bits. In that case, the window in use will have a size lower than 2^N-1 fragments. For example, if the maximum available space for a bitmap is 56 bits, N can be set to 6, and the window size can be set to a maximum of 56 fragments.</p>
<h1 id="rfc.section.9.6">
<a href="#rfc.section.9.6">9.6.</a> <a href="#baseline-mechanism" id="baseline-mechanism">Baseline mechanism</a>
</h1>
<p id="rfc.section.9.6.p.1">The receiver of link fragments SHALL use (1) the sender&#8217;s L2 source address (if present), (2) the destination&#8217;s L2 address (if present), (3) Rule ID and (4) DTag (the latter, if present) to identify all the fragments that belong to a given IPv6 datagram. The fragment receiver may determine the fragment delivery reliability option in use for the fragment based on the Rule ID field in that fragment.</p>
<p id="rfc.section.9.6.p.2">Upon receipt of a link fragment, the receiver starts constructing the original unfragmented packet. It uses the CFN and the order of arrival of each fragment to determine the location of the individual fragments within the original unfragmented packet. For example, it may place the data payload of the fragments within a payload datagram reassembly buffer at the location determined from the CFN and order of arrival of the fragments, and the fragment payload sizes. In Window mode, the fragment receiver also uses the W bit in the received fragments. Note that the size of the original, unfragmented IPv6 packet cannot be determined from fragmentation headers.</p>
<p id="rfc.section.9.6.p.3">When Window mode - ACK on error is used, the fragment receiver starts a timer (denoted &#8220;ACK on Error Timer&#8221;) upon reception of the first fragment for an IPv6 datagram.  The initial value for this timer is not provided by this specification, and is expected to be defined in additional documents.  This timer is reset and restarted every time that a new fragment carrying data from the same IPv6 datagram is received. In Window mode &#8211; ACK on error, after reception of the last fragment of a window (i.e. the fragment with CFN=0 or CFN=2^N-1), if fragment losses have been detected by the fragment receiver in the current window, the fragment receiver MUST transmit an ACK reporting its available information with regard to sucessfully received and missing fragments from the current window.  Upon expiration of the &#8220;ACK on Error Timer&#8221;, if the receiver knows that at least one fragment of the current window has been lost, an ACK MUST be transmitted by the fragment receiver to report received and not received fragments for the current window. The &#8220;ACK on Error Timer&#8221; is then reset and restarted. In Window mode &#8211; ACK on error, the fragment sender retransmits any lost fragments reported in an ACK. The maximum number of ACKs to be sent by the receiver for a specific window, denoted MAX_ACKS_PER_WINDOW, is not stated in this document, and it is expected to be defined in other documents (e.g. technology-specific profiles).</p>
<p id="rfc.section.9.6.p.4">Note that, in Window mode, the first fragment of the window is the one with CFN=2^N-2.  Also note that, in Window mode, the fragment with CFN=0 is considered the last fragment of its window, except for the last fragment of the whole packet (with all CFN bits set to 1, i.e. CFN=2^N-1), which is also the last fragment of the last window.</p>
<p id="rfc.section.9.6.p.5">If Window mode &#8211; ACK &#8220;always&#8221; is used, upon receipt of the last fragment of a window (i.e. the fragment with CFN=0 or CFN=2^N-1), the fragment receiver MUST send an ACK to the fragment sender. The ACK provides feedback on the fragments received and those not received that correspond to the last window. Once all fragments of a window have been received by the fragment receiver (including retransmitted fragments, if any), the latter sends an ACK without a bitmap to the sender, in order to report sucessful reception of all fragments of the window to the fragment sender.</p>
<p id="rfc.section.9.6.p.6">When Window mode - ACK &#8220;always&#8221; is used, the fragment sender starts a timer (denoted &#8220;ACK Always Timer&#8221;) after the first transmission attempt of the last fragment of a window (i.e. the fragment with CFN=0 or CFN=2^N-1). In the same reliability option, if one or more fragments are reported by an ACK to be lost, the sender retransmits those fragments and starts the &#8220;ACK Always Timer&#8221; after the last retransmitted fragment (i.e. the fragment with the lowest CFN) among the set of lost fragments reported by the ACK.  The initial value for the &#8220;ACK Always Timer&#8221; is not provided by this specification, and it is expected to be defined in additional documents. Upon expiration of the timer, if no ACK has been received since the timer start, the sender retransmits the last fragment sent, and it   reinitializes and restarts the timer.  Note that retransmitting the last fragment sent as described serves as an ACK request.  The maximum number of requests for a specific ACK, denoted MAX_ACK_REQUESTS, is not stated in this document, and it is expected to be defined in other documents (e.g. technology-specific profiles). In Window mode &#8211; ACK &#8220;Always&#8221;, the fragment sender retransmits any lost fragments reported in an ACK, as long as the number of retries for each one of those fragments does not exceed MAX_FRAG_RETRIES. The default value for MAX_FRAG_RETRIES is not provided in this document and it is expected to be defined in additional documents. When the fragment sender receives an ACK that confirms correct reception of all fragments of a window, if there are further fragments to be sent for the same IPv6 datagram, the fragment sender proceeds to transmitting subsequent fragments of the next window.</p>
<p id="rfc.section.9.6.p.7">If the recipient receives the last fragment of an IPv6 datagram (i.e. the fragment with CFN=2^N-1), it checks for the integrity of the reassembled IPv6 datagram, based on the MIC received.  In No ACK mode, if the integrity check indicates that the reassembled IPv6 datagram does not match the original IPv6 datagram (prior to fragmentation), the reassembled IPv6 datagram MUST be discarded.  If Window mode - ACK &#8220;Always&#8221; is used, the recipient MUST transmit an ACK to the fragment sender.  The ACK provides feedback on the fragments from the last window that have been received or not per the information available at the receiver.  If Window mode - ACK on error is used, the recipient MUST NOT transmit an ACK to the sender if no losses have been detected for the last window.  If losses have been detected, the recipient MUST then transmit an ACK to the sender to provide feedback on the transmission of the last window of fragments.</p>
<p id="rfc.section.9.6.p.8">If a fragment recipient disassociates from its L2 network, the recipient MUST discard all link fragments of all partially reassembled payload datagrams, and fragment senders MUST discard all not yet transmitted link fragments of all partially transmitted payload (e.g., IPv6) datagrams. Similarly, when a node first receives a fragment of a packet, it starts a reassembly timer. When this time expires, if the entire packet has not been reassembled, the existing fragments MUST be discarded and the reassembly state MUST be flushed. The value for this timer is not provided by this specification, and is expected to be defined in technology-specific profile documents.</p>
<h1 id="rfc.section.9.7">
<a href="#rfc.section.9.7">9.7.</a> <a href="#supporting-multiple-window-sizes" id="supporting-multiple-window-sizes">Supporting multiple window sizes</a>
</h1>
<p id="rfc.section.9.7.p.1">For Window mode operation, implementers may opt to support a single window size or multiple window sizes. The latter, when feasible, may provide performance optimizations. For example, a large window size may be used for IPv6 packets that need to be carried by a large number of fragments. However, when the number of fragments required to carry an IPv6 packet is low, a smaller window size, and thus a shorter bitmap, may be sufficient to provide feedback on all fragments. If multiple window sizes are supported, the Rule ID may be used to signal the window size in use for a specific IPv6 packet transmission.</p>
<h1 id="rfc.section.9.8">
<a href="#rfc.section.9.8">9.8.</a> <a href="#aborting-fragmented-ipv6-datagram-transmissions" id="aborting-fragmented-ipv6-datagram-transmissions">Aborting fragmented IPv6 datagram transmissions</a>
</h1>
<p id="rfc.section.9.8.p.1">For several reasons, a fragment sender or a fragment receiver may want to abort the on-going transmission of one or several fragmented IPv6 datagrams. The entity (either the fragment sender or the fragment receiver) that triggers abortion transmits to the other endpoint a format that only comprises a Rule ID (of size R bits), which signals abortion of all on-going fragmented IPv6 packet transmissions. The specific value to be used for the Rule ID of this abortion signal is not defined in this document, and is expected to be defined in future documents.</p>
<p id="rfc.section.9.8.p.2">Upon transmission or reception of the abortion signal, both entities MUST release any resources allocated for the fragmented IPv6 datagram transmissions being aborted.</p>
<h1 id="rfc.section.9.9">
<a href="#rfc.section.9.9">9.9.</a> <a href="#downlink-fragment-transmission" id="downlink-fragment-transmission">Downlink fragment transmission</a>
</h1>
<p id="rfc.section.9.9.p.1">In some LPWAN technologies, as part of energy-saving techniques, downlink transmission is only possible immediately after an uplink transmission. In order to avoid potentially high delay for fragmented IPv6 datagram transmission in the downlink, the fragment receiver MAY perform an uplink transmission as soon as possible after reception of a fragment that is not the last one. Such uplink transmission may be triggered by the L2 (e.g. an L2 ACK sent in response to a fragment encapsulated in a L2 frame that requires an L2 ACK) or it may be triggered from an upper layer.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#security-considerations" id="security-considerations">Security considerations</a>
</h1>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#security-considerations-for-header-compression" id="security-considerations-for-header-compression">Security considerations for header compression</a>
</h1>
<p id="rfc.section.10.1.p.1">A malicious header compression could cause the reconstruction of a wrong packet that does not match with the original one, such corruption may be detected with end-to-end authentication and integrity mechanisms.  Denial of Service may be produced but its arise other security problems that may be solved with or without header compression.</p>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> <a href="#security-considerations-for-fragmentation" id="security-considerations-for-fragmentation">Security considerations for fragmentation</a>
</h1>
<p id="rfc.section.10.2.p.1">This subsection describes potential attacks to LPWAN fragmentation and suggests possible countermeasures.</p>
<p id="rfc.section.10.2.p.2">A node can perform a buffer reservation attack by sending a first fragment to a target.  Then, the receiver will reserve buffer space for the IPv6 packet.  Other incoming fragmented packets will be dropped while the reassembly buffer is occupied during the reassembly timeout.  Once that timeout expires, the attacker can repeat the same procedure, and iterate, thus creating a denial of service attack.  The (low) cost to mount this attack is linear with the number of buffers at the target node.  However, the cost for an attacker can be increased if individual fragments of multiple packets can be stored in the reassembly buffer.  To further increase the attack cost, the reassembly buffer can be split into fragment-sized buffer slots.  Once a packet is complete, it is processed normally.  If buffer overload occurs, a receiver can discard packets based on the sender behavior, which may help identify which fragments have been sent by an attacker.</p>
<p id="rfc.section.10.2.p.3">In another type of attack, the malicious node is required to have overhearing capabilities.  If an attacker can overhear a fragment, it can send a spoofed duplicate (e.g. with random payload) to the destination.  A receiver cannot distinguish legitimate from spoofed fragments.  Therefore, the original IPv6 packet will be considered corrupt and will be dropped.  To protect resource-constrained nodes from this attack, it has been proposed to establish a binding among the fragments to be transmitted by a node, by applying content- chaining to the different fragments, based on cryptographic hash functionality.  The aim of this technique is to allow a receiver to identify illegitimate fragments.</p>
<p id="rfc.section.10.2.p.4">Further attacks may involve sending overlapped fragments (i.e.  comprising some overlapping parts of the original IPv6 datagram).  Implementers should make sure that correct operation is not affected by such event.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.11.p.1">Thanks to Dominique Barthel, Carsten Bormann, Philippe Clavier, Arunprabhu Kandasamy, Antony Markovski, Alexander Pelov, Pascal Thubert, Juan Carlos Zuniga and Diego Dujovne for useful design consideration and comments.</p>
<h1 id="rfc.references">
<a href="#rfc.references">12.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">12.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2460">[RFC2460]</b></td>
<td class="top">
<a>Deering, S.</a> and <a>R. Hinden</a>, "<a href="http://tools.ietf.org/html/rfc2460">Internet Protocol, Version 6 (IPv6) Specification</a>", RFC 2460, DOI 10.17487/RFC2460, December 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4944">[RFC4944]</b></td>
<td class="top">
<a>Montenegro, G.</a>, <a>Kushalnagar, N.</a>, <a>Hui, J.</a> and <a>D. Culler</a>, "<a href="http://tools.ietf.org/html/rfc4944">Transmission of IPv6 Packets over IEEE 802.15.4 Networks</a>", RFC 4944, DOI 10.17487/RFC4944, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5795">[RFC5795]</b></td>
<td class="top">
<a>Sandlund, K.</a>, <a>Pelletier, G.</a> and <a>L-E. Jonsson</a>, "<a href="http://tools.ietf.org/html/rfc5795">The RObust Header Compression (ROHC) Framework</a>", RFC 5795, DOI 10.17487/RFC5795, March 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7136">[RFC7136]</b></td>
<td class="top">
<a>Carpenter, B.</a> and <a>S. Jiang</a>, "<a href="http://tools.ietf.org/html/rfc7136">Significance of IPv6 Interface Identifiers</a>", RFC 7136, DOI 10.17487/RFC7136, February 2014.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">12.2.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="I-D.ietf-lpwan-overview">[I-D.ietf-lpwan-overview]</b></td>
<td class="top">
<a>Farrell, S.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-lpwan-overview-04">LPWAN Overview</a>", Internet-Draft draft-ietf-lpwan-overview-04, June 2017.</td>
</tr></tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#fragmentation-examples" id="fragmentation-examples">Fragmentation examples</a>
</h1>
<p id="rfc.section.A.p.1">This section provides examples of different fragment delivery reliability options possible on the basis of this specification.</p>
<p><a href="#Fig-Example-Unreliable" class="xref">Figure 16</a> illustrates the transmission of an IPv6 packet that needs 11 fragments in the No ACK option.</p>
<div id="rfc.figure.16"></div>
<div id="Fig-Example-Unreliable"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-------CFN=0--------&gt;|
          |-------CFN=0--------&gt;|
          |-------CFN=0--------&gt;|
          |-------CFN=0--------&gt;|
          |-------CFN=0--------&gt;|
          |-------CFN=0--------&gt;|
          |-------CFN=0--------&gt;|
          |-------CFN=0--------&gt;|
          |-------CFN=0--------&gt;|
          |-------CFN=0--------&gt;|
          |-------CFN=1--------&gt;|MIC checked =&gt;
 &#160; &#160; &#160; &#160; 
</pre>
<p class="figure">Figure 16: Transmission of an IPv6 packet carried by 11 fragments in the No ACK option</p>
<p><a href="#Fig-Example-Win-NoLoss-NACK" class="xref">Figure 17</a> illustrates the transmission of an IPv6 packet that needs 11 fragments in Window mode - ACK on error, for N=3, without losses.</p>
<div id="rfc.figure.17"></div>
<div id="Fig-Example-Win-NoLoss-NACK"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=1, CFN=6-----&gt;|
          |-----W=1, CFN=5-----&gt;|
          |-----W=1, CFN=4-----&gt;|
          |-----W=1, CFN=3-----&gt;|
          |-----W=1, CFN=2-----&gt;|
          |-----W=1, CFN=1-----&gt;|
          |-----W=1, CFN=0-----&gt;|
      (no ACK)
          |-----W=0, CFN=6-----&gt;|
          |-----W=0, CFN=5-----&gt;|
          |-----W=0, CFN=4-----&gt;|
          |-----W=0, CFN=7-----&gt;|MIC checked =&gt;
      (no ACK)

</pre>
<p class="figure">Figure 17: Transmission of an IPv6 packet carried by 11 fragments in Window mode - ACK on error, for N=3, without losses.</p>
<p><a href="#Fig-Example-Rel-Window-NACK-Loss" class="xref">Figure 18</a> illustrates the transmission of an IPv6 packet that needs 11 fragments in Window mode - ACK on error, for N=3, with three losses.</p>
<div id="rfc.figure.18"></div>
<div id="Fig-Example-Rel-Window-NACK-Loss"></div>
<pre>
 &#160; &#160; &#160; &#160; Sender &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=1, CFN=6-----&gt;|
          |-----W=1, CFN=5-----&gt;|
          |-----W=1, CFN=4--X--&gt;|
          |-----W=1, CFN=3-----&gt;|
          |-----W=1, CFN=2--X--&gt;|
          |-----W=1, CFN=1-----&gt;|
          |-----W=1, CFN=0-----&gt;|
          |&lt;-----ACK, W=1-------|Bitmap:11010111
          |-----W=1, CFN=4-----&gt;|
          |-----W=1, CFN=2-----&gt;|   
      (no ACK)     
          |-----W=0, CFN=6-----&gt;|
          |-----W=0, CFN=5-----&gt;|
          |-----W=0, CFN=4--X--&gt;|
          |-----W=0, CFN=7-----&gt;|MIC checked
          |&lt;-----ACK, W=0-------|Bitmap:11000001
          |-----W=0, CFN=4-----&gt;|MIC checked =&gt;
      (no ACK)    

</pre>
<p class="figure">Figure 18: Transmission of an IPv6 packet carried by 11 fragments in Window mode - ACK on error, for N=3, three losses.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-NoLoss" class="xref">Figure 19</a> illustrates the transmission of an IPv6 packet that needs 11 fragments in Window mode - ACK &#8220;always&#8221;, for N=3, without losses. Note: in Window mode, an additional bit will be needed to number windows.</p>
<div id="rfc.figure.19"></div>
<div id="Fig-Example-Rel-Window-ACK-NoLoss"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=1, CFN=6-----&gt;|
          |-----W=1, CFN=5-----&gt;|
          |-----W=1, CFN=4-----&gt;|
          |-----W=1, CFN=3-----&gt;|
          |-----W=1, CFN=2-----&gt;|
          |-----W=1, CFN=1-----&gt;|
          |-----W=1, CFN=0-----&gt;|
          |&lt;-----ACK, W=1-------|no bitmap
          |-----W=0, CFN=6-----&gt;|
          |-----W=0, CFN=5-----&gt;|   
          |-----W=0, CFN=4-----&gt;|
          |-----W=0, CFN=7-----&gt;|MIC checked =&gt;
          |&lt;-----ACK, W=0-------|no bitmap
        (End)    

</pre>
<p class="figure">Figure 19: Transmission of an IPv6 packet carried by 11 fragments in Window mode - ACK "always", for N=3, no losses.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-Loss" class="xref">Figure 20</a> illustrates the transmission of an IPv6 packet that needs 11 fragments in Window mode - ACK &#8220;always&#8221;, for N=3, with three losses.</p>
<div id="rfc.figure.20"></div>
<div id="Fig-Example-Rel-Window-ACK-Loss"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=1, CFN=6-----&gt;|
          |-----W=1, CFN=5-----&gt;|
          |-----W=1, CFN=4--X--&gt;|
          |-----W=1, CFN=3-----&gt;|
          |-----W=1, CFN=2--X--&gt;|
          |-----W=1, CFN=1-----&gt;|
          |-----W=1, CFN=0-----&gt;|
          |&lt;-----ACK, W=1-------|bitmap:11010111
          |-----W=1, CFN=4-----&gt;|
          |-----W=1, CFN=2-----&gt;|
          |&lt;-----ACK, W=1-------|no bitmap
          |-----W=0, CFN=6-----&gt;|
          |-----W=0, CFN=5-----&gt;|   
          |-----W=0, CFN=4--X--&gt;|
          |-----W=0, CFN=7-----&gt;|MIC checked
          |&lt;-----ACK, W=0-------|bitmap:11000001
          |-----W=0, CFN=4-----&gt;|MIC checked =&gt;
          |&lt;-----ACK, W=0-------|no bitmap
        (End)    

</pre>
<p class="figure">Figure 20: Transmission of an IPv6 packet carried by 11 fragments in Window mode - ACK "Always", for N=3, with three losses.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#rule-ids-for-fragmentation" id="rule-ids-for-fragmentation">Rule IDs for fragmentation</a>
</h1>
<p id="rfc.section.B.p.1">Different Rule IDs may be used for different aspects of fragmentation functionality as per this document. A summary of such Rule IDs follows:</p>
<p></p>

<ul>
<li>A fragment, and the reliability option in use for the IPv6 datagram being carried: i) No ACK, ii) Window mode - ACK on error, iii) Window mode - ACK &#8220;always&#8221;. In Window mode, a specific Rule ID may be used for each supported window size.</li>
<li>An ACK message.</li>
<li>A message to abort all on-going transmissions.</li>
</ul>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#note" id="note">Note</a>
</h1>
<p id="rfc.section.C.p.1">Carles Gomez has been funded in part by the Spanish Government (Ministerio de Educacion, Cultura y Deporte) through the Jose Castillejo grant CAS15/00336, and by the ERDF and the Spanish Government through project TEC2016-79988-P.  Part of his contribution to this work has been carried out during his stay as a visiting scholar at the Computer Laboratory of the University of Cambridge.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ana Minaburo</span> 
	  <span class="n hidden">
		<span class="family-name">Minaburo</span>
	  </span>
	</span>
	<span class="org vcardline">Acklio</span>
	<span class="adr">
	  <span class="vcardline">2bis rue de la Chataigneraie</span>

	  <span class="vcardline">
		<span class="locality">35510 Cesson-Sevigne Cedex</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ana@ackl.io">ana@ackl.io</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Laurent Toutain</span> 
	  <span class="n hidden">
		<span class="family-name">Toutain</span>
	  </span>
	</span>
	<span class="org vcardline">IMT-Atlantique</span>
	<span class="adr">
	  <span class="vcardline">2 rue de la Chataigneraie</span>
<span class="vcardline">CS 17607</span>

	  <span class="vcardline">
		<span class="locality">35576 Cesson-Sevigne Cedex</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:Laurent.Toutain@imt-atlantique.fr">Laurent.Toutain@imt-atlantique.fr</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Carles Gomez</span> 
	  <span class="n hidden">
		<span class="family-name">Gomez</span>
	  </span>
	</span>
	<span class="org vcardline">Universitat Polit&#232;cnica de Catalunya</span>
	<span class="adr">
	  <span class="vcardline">C/Esteve Terradas, 7</span>
<span class="vcardline">08860 Castelldefels</span>

	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Spain</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:carlesgo@entel.upc.edu">carlesgo@entel.upc.edu</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/lp-wan/ip-compression">Fork me on GitHub</a></div></div>
</body>
</html>
